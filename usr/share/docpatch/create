#!/bin/bash


## DocPatch -- patching documents that matter
## Copyright (C) 2012 Benjamin Heisig <http://benjamin.heisig.name/>
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.


##
## Create script
##


## About this command
COMMAND_DESC="$COMMAND_CREATE"

SUPPORTED_FORMATS="epub pdf text"


## Checks wether everything is prepared before creating output.
function checks {
  loginfo "Checking wether everything is prepared before creating output."

  logdebug "Checking output directory..."
  if [ ! -d "$OUTPUT_DIR" ]; then
      logdebug "Output directory not found. Create it."
      exe "$MKDIR" -p "$OUTPUT_DIR"
      if [ "$?" -gt 0 ]; then
          logwarning "Cannot create output directory under ${OUTPUT_DIR}."
          logerror "Checks failed."
          return 1
        fi
      logdebug "Output directory created under ${OUTPUT_DIR}."
    else
      logdebug "Output directory found in ${OUTPUT_DIR}."
    fi

  logdebug "Verifying format..."
  local found=0
  for format in $SUPPORTED_FORMATS; do
      if [ "$OUTPUT_FORMAT" == "$format" ]; then
          found=1
          break
        fi
    done
  if [ "$found" -eq 0 ]; then
      logwarning "Format is not supported: $OUTPUT_FORMAT"
      logerror "Checks failed."
      return 1
    fi
  logdebug "Format verified: $OUTPUT_FORMAT"

  logdebug "Checks succeded."
  return 0
}


## Loads meta information
function loadMetaInformation {
  loginfo "Loading meta information..."

  CURRENT_REVISION="$1"

  if [ ! -r "$DOCPATCH_CONF_TARGET" ]; then
      logwarning "Cannot access meta information under ${DOCPATCH_CONF_TARGET}."
      logerror "Failed to load meta information."
      return 1
    fi
  logdebug "Meta information found under ${DOCPATCH_CONF_TARGET}."

  logdebug "Including file..."
  source "$DOCPATCH_CONF_TARGET"
  logdebug "File included."

  logdebug "Meta information loaded."
  return 0
}


## Determines Repository
function determineRepository {
  loginfo "Determining repository..."

  logdebug "Checking argument..."
  if [ -z "$REPOSITORY" ]; then
      logdebug "Argument not set. Use default repository under ${REPO_DIR}."

      logdebug "Checking for existing repository..."
      if [ ! -d "${REPO_DIR}/.git/" ]; then
          lognotice "There is no repository under ${REPO_DIR}."
          logwarning"Cannot use default repository."
          logerror "Failed to determine repository."
          return 1
        fi
      logdebug "Repository found under ${REPO_DIR}."
    else
      logdebug "Cloning repository ${REPOSITORY}..."

      logdebug "Checking for existing repository..."
      if [ -d "${REPO_DIR}/.git/" ]; then
          lognotice "Repository found under ${REPO_DIR}."
          logwarning"Cannot clone repository ${REPOSITORY}."
          logerror "Failed to determine repository."
          return 1
        fi
      logdebug "There is no repository under ${REPO_DIR}."

      logdebug "Creating empty directory..."
      exe "$RM -rf $REPO_DIR"
      exe "$MKDIR -p $REPO_DIR"
      logdebug "Empty directory under $REPO_DIR created."

      logdebug "Cloning repository from ${REPOSITORY}..."
      exe "$GIT clone $REPOSITORY $REPO_DIR"
      if [ "$?" -gt 0 ]; then
          logwarning"Cannot clone repository $REPOSITORY under ${REPO_DIR}."
          logerror "Failed to determine repository."
          return 1
        fi
      logdebug "Repository cloned under ${REPO_DIR}."
    fi

  logdebug "Repository determined."
  return 0
}


## Counts revisions.
function countRevisions {
  loginfo "Counting revisions..."

  cd "$REPO_DIR"
  REVISIONS=`"$GIT" tag -l | "$WC" -l`
  if [ "$?" -gt 0 ]; then
      logerror "Cannot count revisions."
      return 1
    fi
  if [ "$REVISIONS" -eq 1 ]; then
      logdebug "There is 1 revision."
    else
      logdebug "There are $REVISIONS revisions."
    fi

  logdebug "Revisions counted."
  return 0
}


## Determines which revisions are meant.
function determineRevisions {
  loginfo "Determining revisions..."

  logdebug "Parsing argument for revisions..."
  if [ -z "$REVISION" ]; then
      logdebug "No specific revision given. Assuming first revision."
      CURRENT_REVISIONS=0
    elif [ "$REVISION" == "first" ]; then
      logdebug "It's the first revision."
      CURRENT_REVISIONS=0
    elif [ "$REVISION" == "last" ]; then
      logdebug "It's the last revision."
      CURRENT_REVISIONS=$(($REVISIONS - 1))
    elif [ "$REVISION" == "all" ]; then
      logdebug "All revisions selected."

      for (( rev=1; rev < "$REVISIONS"; rev++ )); do
          if [ "$rev" -lt 0 ]; then
              logwarning"Inproperly named revision found: $rev"
              logerror "Failed to determine revisions."
              return 1
            fi

          if [ -n "$CURRENT_REVISIONS" ]; then
              CURRENT_REVISIONS="$CURRENT_REVISIONS "
            fi

          CURRENT_REVISIONS="${CURRENT_REVISIONS}$rev"
          logdebug "Appended revision $rev to list."
        done
    elif [[ "$REVISION" == ${REVISION//[^0-9]/} ]]; then
      if [ "$REVISION" -lt 0 ]; then
          logwarning"Inproperly named revision found: $REVISION"
          logerror "Failed to determine revisions."
          return 1
        fi
      logdebug "Revision $REVISION is meant."
      CURRENT_REVISIONS="$REVISION"
    else
      logdebug "Looking for more than one revision..."
      IFS=","
      for rev in $REVISION; do
          if [ "$rev" -lt 0 ]; then
              logwarning"Argument for one or more revisions is invalid."
              logerror "Failed to determine revisions."
              return 1
            fi

          if [ -n "$CURRENT_REVISIONS" ]; then
              CURRENT_REVISIONS="$CURRENT_REVISIONS "
            fi
          CURRENT_REVISIONS="${CURRENT_REVISIONS}$rev"
          logdebug "Appended revision $rev to list."
        done
      unset IFS
    fi
  logdebug "Found these revisions: $CURRENT_REVISIONS"

  logdebug "Revisions determined."
  return 0
}


## Switches repository to a revision.
##   $1 Revision
function switchRevision {
  loginfo "Switching revision..."

  logdebug "Changing into directory ${REPO_DIR}..."
  cd "$REPO_DIR"

  logdebug "Checking out revision ${1}..."
  exe "$GIT checkout $1"
  if [ "$?" -gt 0 ]; then
      logwarning"Cannot checkout revision ${1}."
      logerror "Failed to switch revision."
      return 1
    fi
  logdebug "Check out done."

  logdebug "Revision switched."
  return 0
}


## Creates output.
function createOutput {
  loginfo "Creating output..."

  logdebug "Iterating through each destinated revision..."
  for current_revision in $CURRENT_REVISIONS; do
      logdebug "Handling revision ${current_revision}..."

      switchRevision "$current_revision"
      if [ "$?" -gt 0 ]; then
          logwarning"Cannot handle revision ${current_revision}."
          logerror "Failed to create output."
          return 1
        fi

      loadMetaInformation "$current_revision"
      if [ "$?" -gt 0 ]; then
          logwarning"Cannot handle revision ${current_revision}."
          logerror "Failed to create output."
          return 1
        fi

      case "$OUTPUT_FORMAT" in
          "epub") produceEPUB "$current_revision"; break;;
          "pdf") producePDF "$current_revision"; break;;
          "text") produceText "$current_revision"; break;;
          *) logerror "Internal error."; return 1;;
        esac
      if [ "$?" -gt 0 ]; then
          logwarning"Cannot handle revision ${current_revision}."
          logerror "Failed to create output."
          return 1
        fi

      logdebug "Handling done."
    done
  logdebug "Iteration done."

  logdebug "Output created."
  return 0
}


## Produces EPUB file.
##   $1 Revision
function produceEPUB {
  loginfo "Producing EPUB..."

  # TODO create metadata.xml
  # TODO --epub-metadata=tpl/metadata.xml --epub-cover-image=tpl/test.png

  local output_file="${OUTPUT_DIR}/${TITLE}_${1}.epub"
  logdebug "Producing file..."
  exe "$PANDOC --from=markdown --toc --output=$output_file --smart ${REPO_DIR}/*.md"
  if [ "$?" -gt 0 ]; then
      logwarning "Cannot produce file ${output_file}."
      logerror "Failed to produce EPUB."
      return 1
    fi
  logdebug "Wrote content to file ${output_file}."

  logdebug "EPUB produced."
  return 0
}


## Produces PDF file.
##   $1 Revision
function producePDF {
  loginfo "Producing PDF..."

  logdebug "Checking for any template file..."
  local tpl_option=""
  local tpl_file="${TPL_DIR}/tpl.tex"
  if [ -r "$tpl_file" ]; then
      logdebug "Template file found under ${tpl_file}."
      local tpl_option="--template=$tpl_file"
    else
      logdebug "No template file found under ${tpl_file}."
    fi

  local output_file="${OUTPUT_DIR}/${TITLE}_${1}.pdf"
  logdebug "Producing file..."
  exe "$MARKDOWN2PDF --from=markdown --toc $tpl_option --output=$output_file ${REPO_DIR}/*.md"
  if [ "$?" -gt 0 ]; then
      logwarning "Cannot produce file ${output_file}."
      logerror "Failed to produce PDF."
      return 1
    fi
  logdebug "Wrote content to file ${output_file}."

  logdebug "PDF produced."
  return 0
}


## Produces plaintext files.
##   $1 Revision
function produceText {
  loginfo "Producing plaintext..."

  local output_file="${OUTPUT_DIR}/${TITLE}_${1}.txt"
  logdebug "Producing file..."
  exe "$PANDOC --from=markdown --output=$output_file --to=plain --standalone ${REPO_DIR}/*.md"
  if [ "$?" -gt 0 ]; then
      logwarning "Cannot produce file ${output_file}."
      logerror "Failed to produce plaintext."
      return 1
    fi
  logdebug "Wrote content to file ${output_file}."

  logdebug "Plaintext produced."
  return 0
}


## Main method
function main {
  # Before work
  preChecks || abort 20

  # Main work
  lognotice "$COMMAND_DESC"

  checks || abort 21

  countRevisions || abort 22

  determineRepository || abort 23

  determineRevisions || abort 24

  createOutput || abort 26

  # After work
  finishing
}


## Prints command specific options.
function printCommandOptions {
  loginfo "Printing command specific options..."

  local formats=""
  for format in $SUPPORTED_FORMATS; do
      if [ -n $formats ]; then
          $formats="${formats}, "
        fi
      $formats="${formats}'$format'"
    done

  prntLn "    -f, --format, --output\t\tSelect output format FORMAT. Supported formats are ${formats}. Defaults to 'pdf'."
  prntLn "    -r, --rev, --revision REV\t\tGenerate output from revision REV. 'first', 'last', 'all' and a comma separated list of revisions are allowed. Defaults to 0."
  prntLn "    -R, --repo, --repository REPO\tSelect repository REPO which will be cloned. Defaults to existing repository under ${REPO_DIR}."

  logdebug "Options printed."
  return 0
}
